import { useEffect, useState } from 'react'
import type { FormEvent } from 'react'
import './App.css'

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL ?? 'http://localhost:8000'
const TOKEN_KEY = 'fax_api_token'

const getInitialToken = () => {
  // Always require fresh login after restart.
  localStorage.removeItem(TOKEN_KEY)
  sessionStorage.removeItem(TOKEN_KEY)
  return ''
}

type ProcessStep = {
  title: string
  description: string
  outcome: string
  label: string
  anchorId: string
}

type ExtractedLine = {
  id: number
  order_id: number
  customer_name: string
  extracted_text: string
  normalized_name: string
  quantity: number
  unit_price: number
  line_total: number
  status: 'matched' | 'needs-review'
}

type Customer = {
  id: number
  name: string
  language?: string
}

type AutoGeneratedDocument = {
  id: number
  document_type: string
  download_url: string
}

type UploadResponse = {
  order_id: number
  status: string
  stored_path: string
  customer_id?: number
  matched_lines: number
  needs_review_lines: number
  auto_processed: boolean
  generated_documents: AutoGeneratedDocument[]
}

const processSteps: ProcessStep[] = [
  {
    title: 'FAX intake',
    description: 'Upload PDF/image from incoming fax to start a full automatic run.',
    outcome: 'Document stored and OCR started',
    label: '01',
    anchorId: 'order-intake',
  },
  {
    title: 'OCR + mapping',
    description: 'System extracts lines and maps products using aliases and master data.',
    outcome: 'Structured order lines',
    label: '02',
    anchorId: 'order-intake',
  },
  {
    title: 'Auto pricing + save',
    description: 'System fills customer/base price and saves sales record automatically.',
    outcome: 'Confirmed sales order',
    label: '03',
    anchorId: 'order-intake',
  },
  {
    title: 'Auto documents',
    description: 'Labels, delivery note, and invoices are generated without manual input.',
    outcome: 'Download-ready PDFs',
    label: '04',
    anchorId: 'pdf-generation',
  },
]

const pdfDeliverables = [
  'order_summary',
  'packing_slip',
  'delivery_note',
  'delivery_detail',
  'invoice',
  'invoice_detail',
  'invoice_statement',
]

const nonFunctionalFocus = [
  'Single-login protected API',
  'All order/OCR/document data stored in SQLite',
  'Automatic end-to-end flow after upload',
  'AWS-ready backend deployment model',
]

const parseJson = async <T,>(response: Response): Promise<T> => {
  const text = await response.text()
  const data = text ? JSON.parse(text) : {}
  if (!response.ok) {
    const detail = (data as { detail?: string }).detail ?? response.statusText ?? 'Request failed'
    throw new Error(detail)
  }
  return data as T
}

const readDownloadFilename = (response: Response, fallbackName: string) => {
  const contentDisposition = response.headers.get('Content-Disposition') ?? ''
  const utf8Match = contentDisposition.match(/filename\*=UTF-8''([^;]+)/i)
  if (utf8Match?.[1]) {
    return decodeURIComponent(utf8Match[1])
  }
  const simpleMatch = contentDisposition.match(/filename=\"?([^\";]+)\"?/i)
  if (simpleMatch?.[1]) {
    return simpleMatch[1]
  }
  return fallbackName
}

const prettyDocumentName = (documentType: string) => documentType.replace(/_/g, ' ')

function App() {
  const [token, setToken] = useState(getInitialToken)
  const [loginError, setLoginError] = useState<string | null>(null)
  const [loginLoading, setLoginLoading] = useState(false)
  const [username, setUsername] = useState('')
  const [password, setPassword] = useState('')

  const [customers, setCustomers] = useState<Customer[]>([])
  const [selectedCustomerId, setSelectedCustomerId] = useState<number | ''>('')

  const [orderLines, setOrderLines] = useState<ExtractedLine[]>([])
  const [orderId, setOrderId] = useState<number | null>(null)
  const [uploading, setUploading] = useState(false)
  const [loadingLines, setLoadingLines] = useState(false)
  const [orderMessage, setOrderMessage] = useState('Upload a fax PDF/image to run full automation.')
  const [uploadError, setUploadError] = useState<string | null>(null)
  const [pdfMessage, setPdfMessage] = useState<string | null>(null)
  const [generatedDocuments, setGeneratedDocuments] = useState<AutoGeneratedDocument[]>([])
  const [fileInputKey, setFileInputKey] = useState(Date.now())

  const scrollToSection = (sectionId: string) => {
    document.getElementById(sectionId)?.scrollIntoView({ behavior: 'smooth', block: 'start' })
  }

  const scrollToOrderIntake = () => {
    scrollToSection('order-intake')
  }

  const authFetch = async (input: RequestInfo | URL, init?: RequestInit) => {
    const headers = new Headers(init?.headers)
    if (token) {
      headers.set('Authorization', `Bearer ${token}`)
    }
    const response = await fetch(input, { ...init, headers })
    if (response.status === 401) {
      setToken('')
    }
    return response
  }

  const handleLogin = async (event: FormEvent<HTMLFormElement>) => {
    event.preventDefault()
    setLoginError(null)
    setLoginLoading(true)
    try {
      const response = await fetch(`${API_BASE_URL}/api/auth/login`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password }),
      })
      const data = await parseJson<{ token: string }>(response)
      setToken(data.token)
      setUsername('')
      setPassword('')
    } catch (error) {
      setLoginError(error instanceof Error ? error.message : 'Login failed')
    } finally {
      setLoginLoading(false)
    }
  }

  const handleLogout = () => {
    setToken('')
  }

  useEffect(() => {
    if (!token) {
      return
    }
    const fetchCustomers = async () => {
      try {
        const response = await authFetch(`${API_BASE_URL}/api/customers`)
        const customerData = await parseJson<Customer[]>(response)
        setCustomers(customerData)
      } catch (error) {
        console.error(error)
      }
    }
    fetchCustomers()
  }, [token])

  const fetchOrderLines = async (id: number) => {
    setLoadingLines(true)
    try {
      const response = await authFetch(`${API_BASE_URL}/api/orders/${id}/lines`)
      const data = await parseJson<ExtractedLine[]>(response)
      setOrderLines(data)
      setOrderMessage(`Order ${id} processed.`)
    } catch (error) {
      setOrderLines([])
      setOrderMessage('Failed to load extracted lines.')
      setUploadError(error instanceof Error ? error.message : 'Failed to load lines')
    } finally {
      setLoadingLines(false)
    }
  }

  const downloadGeneratedDocument = async (downloadUrl: string, fallbackName: string) => {
    const resolvedUrl = downloadUrl.startsWith('http') ? downloadUrl : `${API_BASE_URL}${downloadUrl}`
    const response = await authFetch(resolvedUrl)
    if (!response.ok) {
      const errorText = await response.text()
      throw new Error(errorText || 'Failed to download generated PDF.')
    }
    const blob = await response.blob()
    const objectUrl = URL.createObjectURL(blob)
    const anchor = document.createElement('a')
    anchor.href = objectUrl
    anchor.download = readDownloadFilename(response, fallbackName)
    document.body.appendChild(anchor)
    anchor.click()
    anchor.remove()
    URL.revokeObjectURL(objectUrl)
  }

  const handleUpload = async (event: FormEvent<HTMLFormElement>) => {
    event.preventDefault()
    setUploadError(null)
    setPdfMessage(null)

    const formData = new FormData(event.currentTarget)
    const file = formData.get('faxFile') as File | null
    if (!file) {
      setUploadError('Please select a file first.')
      return
    }

    setUploading(true)
    setGeneratedDocuments([])
    setOrderLines([])
    setOrderMessage('Running OCR + matching + pricing + document generation...')

    try {
      const payload = new FormData()
      payload.append('file', file)
      if (typeof selectedCustomerId === 'number') {
        payload.append('customer_id', String(selectedCustomerId))
      }
      payload.append('auto_process', 'true')

      const response = await authFetch(`${API_BASE_URL}/api/orders/upload`, {
        method: 'POST',
        body: payload,
      })
      const result = await parseJson<UploadResponse>(response)

      setOrderId(result.order_id)
      if (typeof result.customer_id === 'number') {
        setSelectedCustomerId(result.customer_id)
      }
      setGeneratedDocuments(result.generated_documents ?? [])
      await fetchOrderLines(result.order_id)

      setOrderMessage(
        `Automation complete. Matched ${result.matched_lines} line(s), review ${result.needs_review_lines} line(s).`,
      )
      if (result.generated_documents.length) {
        scrollToSection('pdf-generation')
      }
    } catch (error) {
      setUploadError(error instanceof Error ? error.message : 'Upload failed')
    } finally {
      setUploading(false)
      setFileInputKey(Date.now())
    }
  }

  if (!token) {
    return (
      <div className="login-shell">
        <div className="login-card">
          <h1>Login</h1>
          <p>Use your admin credentials to access the FAX automation console.</p>
          <form onSubmit={handleLogin} className="panel-form">
            <label>
              Username
              <input value={username} onChange={(event) => setUsername(event.target.value)} />
            </label>
            <label>
              Password
              <input
                type="password"
                value={password}
                onChange={(event) => setPassword(event.target.value)}
              />
            </label>
            <button type="submit" disabled={loginLoading}>
              {loginLoading ? 'Signing in...' : 'Sign in'}
            </button>
            {loginError && <p className="status-message error">{loginError}</p>}
          </form>
        </div>
      </div>
    )
  }

  return (
    <div className="app-shell">
      <header className="hero">
        <span className="hero-tag">FAX Order Automation</span>
        <h1>One-click automated workflow after OCR.</h1>
        <p className="hero-subtitle">
          Upload a fax PDF/image and the system automatically extracts order data, applies pricing,
          saves the sales order, and generates delivery/invoice PDFs.
        </p>
        <div className="hero-actions">
          <button type="button" onClick={scrollToOrderIntake}>
            Start intake
          </button>
          <button type="button" className="ghost" onClick={handleLogout}>
            Sign out
          </button>
        </div>
      </header>

      <section className="process-grid">
        {processSteps.map((step) => (
          <article className="process-card" key={step.title}>
            <div className="process-label">{step.label}</div>
            <h3>{step.title}</h3>
            <p>{step.description}</p>
            <small>{step.outcome}</small>
            <button type="button" onClick={() => scrollToSection(step.anchorId)}>
              Open step
            </button>
          </article>
        ))}
      </section>

      <section className="workflow-grid" id="order-intake">
        <article className="panel">
          <div className="panel-heading">
            <h2>Automated order intake</h2>
            <p>Single action: upload fax file and run full backend automation.</p>
          </div>
          <form className="panel-form" onSubmit={handleUpload}>
            <label>
              Customer (optional; leave empty for auto-detect)
              <select
                value={selectedCustomerId}
                onChange={(event) => {
                  const value = event.target.value
                  setSelectedCustomerId(value ? Number(value) : '')
                }}
              >
                <option value="">Auto detect from fax</option>
                {customers.map((customer) => (
                  <option key={customer.id} value={customer.id}>
                    {customer.name}
                  </option>
                ))}
              </select>
            </label>
            <label>
              Fax file (PDF / image)
              <input
                key={fileInputKey}
                name="faxFile"
                type="file"
                accept=".pdf,.png,.jpg,.jpeg,.tif,.tiff,image/*,application/pdf"
              />
            </label>
            <div className="ocr-controls">
              <button type="submit" disabled={uploading}>
                {uploading ? 'Processing...' : 'Run full automation'}
              </button>
            </div>
          </form>

          {uploadError && <p className="status-message error">{uploadError}</p>}
          <p className="status-message">{orderMessage}</p>
          {orderId && <p className="order-id">Order ID: {orderId}</p>}

          {loadingLines ? (
            <p className="status-message">Loading extracted lines...</p>
          ) : orderLines.length ? (
            <div className="ocr-line-grid">
              {orderLines.map((line) => (
                <article className="ocr-line-card" key={line.id}>
                  <div className="ocr-line-head">
                    <strong>{line.normalized_name || 'Unmapped product'}</strong>
                    <span className={`status-chip status-${line.status}`}>{line.status}</span>
                  </div>
                  <div className="ocr-line-fields">
                    <div>
                      <small>Extracted text</small>
                      <p>{line.extracted_text || '-'}</p>
                    </div>
                    <div>
                      <small>Quantity</small>
                      <p>{line.quantity}</p>
                    </div>
                    <div>
                      <small>Unit price</small>
                      <p>{line.unit_price.toFixed(2)}</p>
                    </div>
                    <div>
                      <small>Line total</small>
                      <p>{line.line_total.toFixed(2)}</p>
                    </div>
                  </div>
                </article>
              ))}
            </div>
          ) : (
            <p className="table-placeholder">No lines yet. Upload a file to process.</p>
          )}

          <div className="step-actions">
            <button
              type="button"
              className="ghost"
              onClick={() => scrollToSection('pdf-generation')}
              disabled={!generatedDocuments.length}
            >
              Go to generated documents
            </button>
          </div>
        </article>
      </section>

      <section className="panel-grid-two" id="pdf-generation">
        <article className="panel">
          <div className="panel-heading">
            <h2>Generated documents</h2>
            <p>Documents are created automatically after processing.</p>
          </div>

          <div className="pdf-list">
            {pdfDeliverables.map((documentType) => (
              <div key={documentType} className="pdf-item">
                <strong>{prettyDocumentName(documentType)}</strong>
              </div>
            ))}
          </div>

          {generatedDocuments.length ? (
            <div className="generated-docs">
              <h4>Current order files</h4>
              <div className="generated-doc-list">
                {generatedDocuments.map((document) => (
                  <button
                    key={document.id}
                    type="button"
                    onClick={() => {
                      void downloadGeneratedDocument(
                        document.download_url,
                        `${document.document_type}-${orderId ?? 'order'}.pdf`,
                      ).catch((error: unknown) => {
                        setPdfMessage(error instanceof Error ? error.message : 'Download failed')
                      })
                    }}
                  >
                    Download {prettyDocumentName(document.document_type)}
                  </button>
                ))}
              </div>
            </div>
          ) : (
            <p className="table-placeholder">No generated files yet.</p>
          )}

          {pdfMessage && <p className="status-message error">{pdfMessage}</p>}
        </article>
      </section>

      <section className="notes">
        <h2>System focus</h2>
        <ul>
          {nonFunctionalFocus.map((item) => (
            <li key={item}>{item}</li>
          ))}
        </ul>
      </section>
    </div>
  )
}

export default App
